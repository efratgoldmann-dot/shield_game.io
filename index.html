<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Placer.ai: Audio Survivor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e24;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 10px; left: 10px;
            pointer-events: none;
            z-index: 10;
        }
        .bar-container {
            width: 250px; height: 20px;
            background: #333;
            border: 2px solid #555;
            margin-bottom: 5px;
            position: relative;
        }
        .bar-fill {
            height: 100%; width: 0%;
            transition: width 0.2s;
        }
        #hp-bar { background-color: #2ecc71; width: 100%; } 
        #xp-bar { background-color: #676DFD; } 
        
        h1 { margin: 0; font-size: 20px; text-shadow: 2px 2px 0 #000; letter-spacing: 1px;}
        .label { font-size: 12px; color: #aaa; text-transform: uppercase; letter-spacing: 1px; }
        
        #powers-list {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .power-item {
            display: flex;
            align-items: center;
            background: rgba(103, 109, 253, 0.2);
            padding: 5px 10px;
            border-radius: 4px;
            width: fit-content;
            border-left: 3px solid #676DFD;
            font-size: 14px;
        }
        .power-icon { margin-right: 8px; font-size: 16px; }
        .power-count { font-weight: bold; color: #fff; margin-left: 5px; }

        #active-buffs {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .buff-item {
            color: #f1c40f;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
            animation: pulse 1s infinite;
        }

        #upgrade-screen {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(30, 30, 36, 0.95);
            z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .cards-container {
            display: flex; gap: 20px; margin-top: 20px;
            flex-wrap: wrap; justify-content: center;
        }
        .card {
            background: #2b2b36;
            border: 2px solid #444;
            width: 220px; padding: 25px;
            text-align: center; cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
            position: relative;
            border-radius: 8px;
        }
        .card.selected, .card:hover {
            transform: translateY(-5px);
            background: #3a3a4a;
            border-color: #676DFD;
            box-shadow: 0 5px 20px rgba(103, 109, 253, 0.3);
        }
        .card h3 { color: #676DFD; margin-top: 0; font-size: 18px;}
        .card p { font-size: 13px; color: #ccc; line-height: 1.4; }
        
        #controls-hint {
            margin-top: 30px;
            color: #777;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #pause-screen {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 15;
            display: none; 
            align-items: center; justify-content: center;
        }
        #pause-text {
            font-size: 80px; color: white; font-weight: bold; letter-spacing: 5px; text-shadow: 0 0 20px #000;
        }

        #wave-warning {
            display: none; position: absolute; top: 20%; width: 100%;
            text-align: center; font-size: 40px; color: #e74c3c;
            font-weight: bold; text-shadow: 0 0 10px red; pointer-events: none;
            animation: pulse 0.5s infinite alternate;
            font-family: monospace;
        }
        @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

        #game-over {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; background: #1e1e24;
            padding: 50px; border: 2px solid #e74c3c; z-index: 30;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        button {
            padding: 12px 24px; font-size: 16px; cursor: pointer;
            background: #676DFD; color: white; border: none; font-weight: bold; 
            margin-top: 20px; border-radius: 4px;
        }
        button:hover { background: #555ce0; }
        
        #restart-hint { margin-top: 10px; color: #aaa; font-size: 12px; }
        #final-level { font-size: 28px; font-weight: bold; color: #fff; } /* Made stage text bigger */
    </style>
</head>
<body>

    <div id="ui">
        <h1>PLANNED DEVELOPMENT V.<span id="level-display">1.0</span></h1>
        
        <div class="label">Confidence Score</div>
        <div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div>
        
        <div class="label">Trade Area Analysis</div>
        <div class="bar-container"><div id="xp-bar" class="bar-fill"></div></div>
        
        <div style="margin-top: 10px">Visits: <span id="score-display">0</span></div> <!-- Changed to Visits -->
        <div>Uptime: <span id="time-display">0:00</span></div>
        <div style="color: #777; font-size: 12px;">Lat/Long: <span id="coord-display">0, 0</span></div>
        
        <div id="powers-list"></div>
        <div id="active-buffs"></div>
    </div>

    <div id="wave-warning">‚ö†Ô∏è SEASONAL TRAFFIC SPIKE DETECTED ‚ö†Ô∏è</div>

    <div id="pause-screen">
        <div id="pause-text">PAUSED</div>
    </div>

    <div id="upgrade-screen">
        <h1 style="font-size: 30px; color: white;">NEW METRIC UNLOCKED</h1>
        <p style="color: #aaa;">Select a feature to add to your dashboard</p>
        <div class="cards-container" id="cards-container"></div>
        <div id="controls-hint">Use ‚¨ÖÔ∏è ‚û°Ô∏è Arrows to move, ENTER to Select</div>
    </div>

    <div id="game-over">
        <h1 style="font-size: 30px; color: #e74c3c;">ANALYSIS FAILED</h1>
        <p>Market Landscape too volatile. Report Aborted.</p>
        <p style="font-size: 16px; color: #aaa;">Development Stage: <br><span id="final-level">1.0</span></p>
        <button onclick="location.reload()">RESTART QUERY</button>
        <div id="restart-hint">Press ENTER to Restart</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- ASSET LOADING ---
        const playerSprite = new Image(); playerSprite.src = 'player.png';
        const enemyNoiseSprite = new Image(); enemyNoiseSprite.src = 'Enemies/Error.png';
        const enemyNoiseSprite2 = new Image(); enemyNoiseSprite2.src = 'Enemies/Error1.png';
        const enemyEliteSprite = new Image(); enemyEliteSprite.src = 'Enemies/Report Error.png';
        const magnetSprite = new Image(); magnetSprite.src = 'magnet.png';
        const piSprite = new Image(); piSprite.src = 'AbilityIcons/Pi.png';

        // --- BRAND DATA ---
        const storeData = [
            { file: 'locations/Starbucks.png', name: 'Starbucks', type: 'coffee', label: 'CAFFEINE RUSH' },
            { file: 'locations/Dunkin.png', name: 'Dunkin', type: 'coffee', label: 'SUGAR RUSH' },
            { file: 'locations/McDonalds.png', name: 'McDonalds', type: 'food', label: 'CALORIE SPIKE' },
            { file: 'locations/Burger King.png', name: 'Burger King', type: 'food', label: 'WHOPPER MIGHT' },
            { file: 'locations/KFC.png', name: 'KFC', type: 'food', label: 'CRISPY POWER' },
            { file: 'locations/Apple.png', name: 'Apple', type: 'tech', label: 'PROCESSOR UPGRADE' },
            { file: 'locations/Target.png', name: 'Target', type: 'retail', label: 'MARKET REACH' },
            { file: 'locations/Walmart.png', name: 'Walmart', type: 'retail', label: 'MARKET REACH' },
            { file: 'locations/7Eleven.png', name: '7-Eleven', type: 'grocer', label: 'RESTOCK' },
            { file: 'locations/Aldi.png', name: 'Aldi', type: 'grocer', label: 'RESTOCK' },
            { file: 'locations/GAP.png', name: 'GAP', type: 'grocer', label: 'RETAIL THERAPY' }
        ];

        let spritesLoaded = 0;
        const checkLoad = () => { spritesLoaded++; };
        playerSprite.onload = checkLoad;
        enemyNoiseSprite.onload = checkLoad;
        enemyNoiseSprite2.onload = checkLoad;
        enemyEliteSprite.onload = checkLoad;
        storeData.forEach(store => {
            store.img = new Image();
            store.img.src = store.file;
            store.img.onload = checkLoad;
        });
        piSprite.onload = checkLoad;

        // --- AUDIO ENGINE (8-BIT SYNTH) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        let musicTick = 0;
        const musicMelody = [130.81, 155.56, 174.61, 196.00]; 

        function playMusicNote(freq) {
            if (audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.015, audioCtx.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        }

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
            else if (type === 'pickup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, now);
                osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            else if (type === 'powerup') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            }
            else if (type === 'magnet') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(600, now + 1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 1);
                osc.start(now);
                osc.stop(now + 1);
            }
            else if (type === 'levelup') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(554, now + 0.1);
                osc.frequency.setValueAtTime(659, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            }
        }

        // --- CONFIG & STATE ---
        const TILE_SIZE = 400; 
        const OBSTACLE_SIZE = 60;
        
        let gameState = 'PLAYING';
        let isPaused = false; 
        let score = 0;
        let frame = 0;
        let timeSeconds = 0;
        let screenShake = 0; 
        
        let currentUpgradeChoices = [];
        let selectedUpgradeIndex = 0;

        const buffs = { speed: 0, damage: 0, rapid: 0, magnet: 0 };

        const player = {
            worldX: 0, worldY: 0,
            size: 40, speed: 2.88, 
            hp: 100, maxHp: 100,
            xp: 0, xpToNextLevel: 10, level: 1,
            fireRate: 55, 
            bulletSpeed: 5.04, 
            bulletDamage: 25,
            projectileCount: 1, piercing: 0,
            recoilX: 0, recoilY: 0 
        };

        const keys = {};
        let bullets = [];
        let enemies = [];
        let gems = [];
        let piPickups = [];
        let damageNumbers = [];
        let particles = [];
        let storeLocations = [];
        let magnetPickups = []; 
        let trail = []; 
        
        // Ability icons: use image files from the AbilityIcons folder
        const AbilityIcons = {
            rapid: '<img src="AbilityIcons/RapidRefresh.png" width="20" height="20" alt="Rapid Refresh" />',
            might: '<img src="AbilityIcons/TradeAreaAnalysis.png" width="20" height="20" alt="Area Analysis" />',
            speed: '<img src="AbilityIcons/ChainLandscape.png" width="20" height="20" alt="Market Landscape" />',
            heal: '<img src="AbilityIcons/Loyalty.png" width="20" height="20" alt="Loyalty" />',
            multi: '<img src="AbilityIcons/Cannibalization.png" width="20" height="20" alt="Cannibalization" />',
            pierce: '<img src="AbilityIcons/VoidAnalysis.png" width="20" height="20" alt="Void Analysis" />',
            pi: '<img src="AbilityIcons/Pi.png" width="20" height="20" alt="Pi" />'
        };

        const possibleUpgrades = [
            { id: 'rapid', iconId: 'rapid', name: 'Rapid Refresh', count: 0, desc: 'Update Metrics 15% Faster', apply: () => player.fireRate = Math.max(5, Math.floor(player.fireRate * 0.85)) },
            { id: 'might', iconId: 'might', name: 'Area Analysis', count: 0, desc: '+15 Insight Power', apply: () => player.bulletDamage += 15 },
            { id: 'speed', iconId: 'speed', name: 'Market Landscape', count: 0, desc: 'Navigate Market +15% Faster', apply: () => player.speed *= 1.15 },
            { id: 'heal', iconId: 'heal', name: 'Loyalty Program', count: 0, desc: 'Restore Confidence & Retention', apply: () => { player.maxHp += 20; player.hp = player.maxHp; } },
            { id: 'multi', iconId: 'multi', name: 'Cannibalization', count: 0, desc: 'Analyze +1 Store Overlay', apply: () => player.projectileCount++ },
            { id: 'pierce', iconId: 'pierce', name: 'Void Analysis', count: 0, desc: 'Identify Gaps (Pierce +1)', apply: () => player.piercing++ }
        ];

        function generateWorldStores() {
            for(let i=0; i<60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 10000 + 500; 
                storeLocations.push(new StoreLocation(
                    player.worldX + Math.cos(angle) * dist,
                    player.worldY + Math.sin(angle) * dist
                ));
            }
        }

        window.addEventListener('keydown', e => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (e.code === 'Space' && gameState === 'PLAYING') {
                isPaused = !isPaused;
                document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            }
            if (gameState === 'GAME_OVER' && e.key === 'Enter') location.reload();
            if (gameState === 'LEVEL_UP') {
                if (e.key === 'ArrowLeft') { selectedUpgradeIndex = (selectedUpgradeIndex - 1 + 3) % 3; updateCardSelectionVisuals(); } 
                else if (e.key === 'ArrowRight') { selectedUpgradeIndex = (selectedUpgradeIndex + 1) % 3; updateCardSelectionVisuals(); } 
                else if (e.key === 'Enter') selectUpgrade(selectedUpgradeIndex);
                return;
            }
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        function getObstacleAt(gridX, gridY) {
            const seed = Math.sin(gridX * 12.9898 + gridY * 78.233) * 43758.5453;
            const rand = seed - Math.floor(seed);
            if (rand > 0.8) return { x: gridX * TILE_SIZE + (rand * 100), y: gridY * TILE_SIZE + (rand * 200), type: 'silo' };
            return null;
        }

        function checkWallCollision(x, y, radius) {
            const gx = Math.floor(x / TILE_SIZE);
            const gy = Math.floor(y / TILE_SIZE);
            for (let i = gx - 1; i <= gx + 1; i++) {
                for (let j = gy - 1; j <= gy + 1; j++) {
                    const obs = getObstacleAt(i, j);
                    if (obs) {
                        const closestX = Math.max(obs.x, Math.min(x, obs.x + OBSTACLE_SIZE));
                        const closestY = Math.max(obs.y, Math.min(y, obs.y + OBSTACLE_SIZE));
                        const dx = x - closestX;
                        const dy = y - closestY;
                        if ((dx * dx + dy * dy) < (radius * radius)) return true;
                    }
                }
            }
            return false;
        }
        
        function explodeAllEnemies(originX, originY) {
            if (enemies.length === 0) return;
            let totalScore = 0;
            enemies.forEach(e => {
                totalScore += e.xpValue || 10;
                for (let k = 0; k < 20; k++) particles.push(new Particle(e.x, e.y, '#e74c3c'));
                gems.push(new Gem(e.x, e.y, e.xpValue || 5, '#f1c40f'));
            });
            enemies = [];
            score += totalScore;
            document.getElementById('score-display').innerText = score;
            damageNumbers.push(new DamageText(originX, originY, 'œÄ NUKED', '#f1c40f'));
            playSound('levelup');
        }
        
        class MagnetPickup {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = 30; this.bobOffset = 0;
            }
            update() { this.bobOffset = Math.sin(frame * 0.1) * 5; }
            draw(ctx, camX, camY) {
                if (magnetSprite.complete && magnetSprite.naturalWidth !== 0) {
                    ctx.drawImage(magnetSprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    const x = this.x - camX; const y = this.y - camY + this.bobOffset;
                    ctx.fillStyle = '#ecf0f1';
                    ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.arc(x - 10, y + 5, 8, 0, Math.PI * 2); ctx.arc(x + 10, y + 5, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3498db'; ctx.font = '10px Arial'; ctx.fillText("DATA SYNC", x - 25, y - 15);
                }
            }
        }

        class PiPickup {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = 34; this.bobOffset = 0;
            }
            update() { this.bobOffset = Math.sin(frame * 0.12) * 6; }
            draw(ctx, camX, camY) {
                if (piSprite.complete && piSprite.naturalWidth !== 0) {
                    ctx.drawImage(piSprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    const x = this.x - camX; const y = this.y - camY + this.bobOffset;
                    ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.font = '16px Arial'; ctx.fillText('œÄ', x-6, y+6);
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * 0.72; 
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.life = 60; this.size = Math.random() * 6 + 4; 
            }
            update() {
                this.x += this.dx; this.y += this.dy;
                this.dx *= 0.95; this.dy *= 0.95;
                this.life--; this.size *= 0.96; 
            }
            draw(ctx, camX, camY) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - camX, this.y - camY, this.size, this.size);
            }
        }

        class StoreLocation {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = 75; 
                this.bobOffset = 0;
                const randomStore = storeData[Math.floor(Math.random() * storeData.length)];
                this.sprite = randomStore.img;
                this.label = randomStore.label;
                this.name = randomStore.name;
                this.type = randomStore.type;
            }
            update() { this.bobOffset = Math.sin(frame * 0.1) * 5; }
            draw(ctx, camX, camY) {
                if (this.sprite && this.sprite.complete) {
                     ctx.drawImage(this.sprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    ctx.fillStyle = '#2ecc71';
                    ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY + this.bobOffset, 25, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        class Bullet {
            constructor(x, y, targetX, targetY, angleOffset = 0) {
                this.x = x; this.y = y;
                const angle = Math.atan2(targetY - y, targetX - x) + angleOffset;
                this.dx = Math.cos(angle) * player.bulletSpeed;
                this.dy = Math.sin(angle) * player.bulletSpeed;
                this.radius = 5; this.life = 100;
                this.pierce = player.piercing;
                this.hitList = [];
                playSound('shoot'); 
            }
            update() {
                this.x += this.dx; this.y += this.dy; this.life--;
                if (checkWallCollision(this.x, this.y, 2)) this.life = 0;
            }
            draw(ctx, camX, camY) {
                let color = '#676DFD';
                if (buffs.damage > 0) color = '#e74c3c'; 
                if (buffs.rapid > 0) color = '#f1c40f'; 

                if (this.pierce > 0) {
                    ctx.shadowBlur = 10; ctx.shadowColor = color;
                    ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY, this.radius + 2, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY, this.radius, 0, Math.PI * 2); ctx.fill();
                }
            }
        }

        class Enemy {
            constructor(isElite = false, isBoss = false) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(canvas.width, canvas.height) / 2 + 100;
                this.x = player.worldX + Math.cos(angle) * dist;
                this.y = player.worldY + Math.sin(angle) * dist;
                this.vx = 0;
                this.vy = 0;
                const difficultyMultiplier = 1 + (timeSeconds / 120);
                this.isElite = isElite;
                this.isBoss = isBoss;

                if (this.isBoss) {
                    this.size = 140; // BIGGEST
                    this.speed = (0.5 + (player.level * 0.002)) * difficultyMultiplier; 
                    this.hp = (500 + (player.level * 100)) * difficultyMultiplier;
                    this.color = '#f1c40f';
                    this.xpValue = 1000; // BIG PRICE
                    this.sprite = enemyNoiseSprite2; // Error1.png
                    this.mass = 8.0; 
                } else if (this.isElite) {
                    this.size = 65; 
                    this.speed = (0.65 + (player.level * 0.003)) * difficultyMultiplier; 
                    this.hp = (100 + (player.level * 20)) * difficultyMultiplier;
                    this.color = '#e74c3c';
                    this.xpValue = 50; 
                    this.sprite = enemyEliteSprite;
                    this.mass = 2.5; 
                } else {
                    this.size = 30; 
                    this.speed = (0.72 + (player.level * 0.007)) * difficultyMultiplier; 
                    this.hp = (20 + (player.level * 5)) * difficultyMultiplier;
                    this.color = '#7f8c8d'; 
                    this.xpValue = 5; 
                    this.sprite = enemyNoiseSprite; 
                    this.mass = 1; 
                }
                this.maxHp = this.hp;
            }
            update() {
                const angle = Math.atan2(player.worldY - this.y, player.worldX - this.x);
                const nextX = this.x + Math.cos(angle) * this.speed + this.vx;
                const nextY = this.y + Math.sin(angle) * this.speed + this.vy;
                if (!checkWallCollision(nextX, this.y, this.size/2)) this.x = nextX;
                if (!checkWallCollision(this.x, nextY, this.size/2)) this.y = nextY;
                this.vx *= 0.85;
                this.vy *= 0.85;
            }
            draw(ctx, camX, camY) {
                if (Math.abs(this.x - player.worldX) > canvas.width || Math.abs(this.y - player.worldY) > canvas.height) return;
                let sprite = this.sprite;
                if (sprite.complete && sprite.naturalWidth !== 0) {
                     ctx.drawImage(sprite, this.x - camX - this.size/2, this.y - camY - this.size/2, this.size, this.size);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x - camX - this.size/2, this.y - camY - this.size/2, this.size, this.size);
                }
            }
        }

        class Gem {
            constructor(x, y, value, color) {
                this.x = x; this.y = y; this.value = value; this.size = 8;
                this.color = color || '#3498db';
                if (value > 10) this.size = 12; 
                if (value >= 1000) this.size = 30; // Boss gem size
                this.beingSucked = false; 
            }
            draw(ctx, camX, camY) {
                if (this.beingSucked) ctx.fillStyle = '#fff';
                else ctx.fillStyle = this.color;
                
                ctx.beginPath();
                ctx.moveTo(this.x - camX, this.y - camY - this.size);
                ctx.lineTo(this.x - camX + this.size, this.y - camY);
                ctx.lineTo(this.x - camX, this.y - camY + this.size);
                ctx.lineTo(this.x - camX - this.size, this.y - camY);
                ctx.fill();
            }
        }

        class DamageText {
            constructor(x, y, text, color) {
                this.x = x; this.y = y; this.text = text; 
                this.life = 180; 
                this.dy = -0.21; 
                this.color = color || '#676DFD';
            }
            update() { this.y += this.dy; this.life--; }
            draw(ctx, camX, camY) {
                ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial';
                ctx.fillText(this.text, this.x - camX, this.y - camY);
            }
        }

        function spawnManager() {
            let spawnRate = Math.max(7, 83 - (player.level * 2) - Math.floor(timeSeconds / 10)); 
            
            if (frame % spawnRate === 0) {
                const rand = Math.random();
                let isElite = rand < 0.01;
                let isBoss = rand < 0.002; // MOST RARE
                enemies.push(new Enemy(isElite, isBoss));
            }
            
            if (frame % 2500 === 0 && frame > 500) {
                 const angle = Math.random() * Math.PI * 2;
                 const dist = 500; 
                 magnetPickups.push(new MagnetPickup(
                     player.worldX + Math.cos(angle) * dist,
                     player.worldY + Math.sin(angle) * dist
                 ));
            }

            if (frame % 2500 === 0 && frame > 100) triggerHorde();
            if (frame % 60 === 0) enemies = enemies.filter(e => Math.hypot(e.x - player.worldX, e.y - player.worldY) < 2500);
        }

        function triggerHorde() {
            const messages = ["‚ö†Ô∏è SEASONAL TRAFFIC SPIKE ‚ö†Ô∏è", "‚ö†Ô∏è BLACK FRIDAY CROWDS ‚ö†Ô∏è", "‚ö†Ô∏è COMPETITOR GRAND OPENING ‚ö†Ô∏è", "‚ö†Ô∏è VIRAL TREND DETECTED ‚ö†Ô∏è"];
            const msg = messages[Math.floor(Math.random() * messages.length)];
            const warning = document.getElementById('wave-warning');
            warning.innerText = msg;
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 3000);
            const count = 20 + player.level;
            for(let i=0; i<count; i++) {
                setTimeout(() => enemies.push(new Enemy(Math.random() < 0.05, false)), i * 70);
            }
        }

        function update() {
            if (frame % 33 === 0) { 
                playMusicNote(musicMelody[musicTick % musicMelody.length]);
                musicTick++;
            }

            if (frame % 60 === 0) {
                timeSeconds++;
                const m = Math.floor(timeSeconds/60);
                const s = timeSeconds%60;
                document.getElementById('time-display').innerText = `${m}:${s<10?'0'+s:s}`;
                document.getElementById('coord-display').innerText = `${Math.floor(player.worldX)}, ${Math.floor(player.worldY)}`;
            }

            for (const key in buffs) {
                if (buffs[key] > 0) buffs[key]--;
            }
            updateBuffUI();

            if (screenShake > 0) screenShake *= 0.9;
            player.recoilX *= 0.8;
            player.recoilY *= 0.8;

            if (frame % 5 === 0 && player.speed > 2.5) { 
                trail.push({x: player.worldX, y: player.worldY, life: 15});
            }
            for(let i = trail.length - 1; i >= 0; i--) {
                trail[i].life--;
                if(trail[i].life <= 0) trail.splice(i, 1);
            }

            let currentSpeed = player.speed;
            if (buffs.speed > 0) currentSpeed *= 1.5; 

            let dx = 0, dy = 0;
            if (keys['ArrowUp'] || keys['w']) dy = -currentSpeed;
            if (keys['ArrowDown'] || keys['s']) dy = currentSpeed;
            if (keys['ArrowLeft'] || keys['a']) dx = -currentSpeed;
            if (keys['ArrowRight'] || keys['d']) dx = currentSpeed;

            if (dx !== 0 || dy !== 0) {
                if (!checkWallCollision(player.worldX + dx, player.worldY, player.size/3)) player.worldX += dx;
                if (!checkWallCollision(player.worldX, player.worldY + dy, player.size/3)) player.worldY += dy;
            }

            let currentFireRate = player.fireRate;
            if (buffs.rapid > 0) currentFireRate = Math.max(5, Math.floor(currentFireRate * 0.5)); 

            if (frame % Math.floor(currentFireRate) === 0) {
                let nearest = null; let minDist = Infinity;
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - player.worldX, e.y - player.worldY);
                    if (dist < minDist) { minDist = dist; nearest = e; }
                });

                if (nearest && minDist < 700) {
                    const shootAngle = Math.atan2(nearest.y - player.worldY, nearest.x - player.worldX);
                    player.recoilX = -Math.cos(shootAngle) * 8;
                    player.recoilY = -Math.sin(shootAngle) * 8;

                    for(let i=0; i<player.projectileCount; i++) {
                        const spread = (i - (player.projectileCount-1)/2) * 0.2; 
                        bullets.push(new Bullet(player.worldX, player.worldY, nearest.x, nearest.y, spread));
                    }
                }
            }

            bullets.forEach((b, i) => {
                b.update();
                if (b.life <= 0) bullets.splice(i, 1);
            });
            enemies.forEach(e => e.update());
            damageNumbers.forEach((d, i) => {
                d.update();
                if (d.life <= 0) damageNumbers.splice(i, 1);
            });
            particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) particles.splice(i, 1);
            });
            storeLocations.forEach((h, i) => { h.update(); });
            magnetPickups.forEach((m, i) => { m.update(); });

            spawnManager();
            checkCollisions();
            updateUI();
            frame++;
        }

        function checkCollisions() {
            let currentDamage = player.bulletDamage;
            if (buffs.damage > 0) currentDamage *= 2; 

            for (let i = bullets.length - 1; i >= 0; i--) {
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const b = bullets[i]; const e = enemies[j];
                    if (b.hitList.includes(e)) continue;

                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                        e.hp -= currentDamage;
                        
                        const pushForce = 8;
                        const angle = Math.atan2(e.y - b.y, e.x - b.x);
                        e.vx += Math.cos(angle) * (pushForce / e.mass);
                        e.vy += Math.sin(angle) * (pushForce / e.mass);

                        b.hitList.push(e);
                        damageNumbers.push(new DamageText(e.x, e.y, Math.floor(currentDamage)));
                        
                        playSound('hit');

                        if (e.hp <= 0) {
                            let gemColor = '#3498db';
                            if (e.isElite) gemColor = '#e74c3c';
                            if (e.isBoss) gemColor = '#f1c40f'; // Gold gem for Boss
                            
                            gems.push(new Gem(e.x, e.y, e.xpValue, gemColor));
                            // Very rare chance to spawn the Pi collectible
                            if (Math.random() < 0.002) {
                                piPickups.push(new PiPickup(e.x, e.y));
                            }
                            enemies.splice(j, 1);
                            score += e.xpValue;
                            document.getElementById('score-display').innerText = score;
                        }

                        if (b.pierce > 0) b.pierce--;
                        else { hit = true; break; }
                    }
                }
                if (hit) bullets.splice(i, 1);
            }

            enemies.forEach(e => {
                if (Math.hypot(player.worldX - e.x, player.worldY - e.y) < (player.size/2 + e.size/2)) {
                    const dmg = e.isBoss ? 5.0 : (e.isElite ? 2.0 : 0.5);
                    player.hp -= dmg;
                    screenShake = 12; 
                    for(let k=0; k<15; k++) { particles.push(new Particle(player.worldX, player.worldY, '#676DFD')); }
                    
                    if (frame % 10 === 0) playSound('hit');

                    if (player.hp <= 0) {
                        gameState = 'GAME_OVER';
                        document.getElementById('game-over').style.display = 'block';
                        document.getElementById('final-level').innerText = player.level + '.0';
                    }
                }
            });

            let magnetRange = 150;
            if (buffs.magnet > 0) magnetRange = 500; 

            for (let i = gems.length - 1; i >= 0; i--) {
                const g = gems[i];
                const dist = Math.hypot(player.worldX - g.x, player.worldY - g.y);
                
                if (g.beingSucked) {
                    g.x += (player.worldX - g.x) * 0.057; 
                    g.y += (player.worldY - g.y) * 0.057;
                } else if (dist < magnetRange) { 
                    const magSpeed = buffs.magnet > 0 ? 0.21 : 0.108; 
                    g.x += (player.worldX - g.x) * magSpeed; 
                    g.y += (player.worldY - g.y) * magSpeed; 
                }

                if (dist < 30) { 
                    player.xp += g.value;
                    gems.splice(i, 1);
                    playSound('pickup'); 
                    if (player.xp >= player.xpToNextLevel) levelUp();
                }
            }

            for (let i = magnetPickups.length - 1; i >= 0; i--) {
                const m = magnetPickups[i];
                if (Math.hypot(player.worldX - m.x, player.worldY - m.y) < (player.size/2 + m.size/2)) {
                    damageNumbers.push(new DamageText(player.worldX, player.worldY, "DATA SYNC INITIATED", '#3498db'));
                    gems.forEach(g => g.beingSucked = true);
                    playSound('magnet'); 
                    magnetPickups.splice(i, 1);
                }
            }

            for (let i = piPickups.length - 1; i >= 0; i--) {
                const p = piPickups[i];
                if (Math.hypot(player.worldX - p.x, player.worldY - p.y) < (player.size/2 + p.size/2)) {
                    explodeAllEnemies(player.worldX, player.worldY);
                    playSound('powerup');
                    piPickups.splice(i, 1);
                }
            }

            for (let i = storeLocations.length - 1; i >= 0; i--) {
                const s = storeLocations[i];
                if (Math.hypot(player.worldX - s.x, player.worldY - s.y) < (player.size/2 + s.size/2)) {
                    const buffDuration = 600; 
                    switch(s.type) {
                        case 'coffee': buffs.speed = buffDuration; break;
                        case 'food': buffs.damage = buffDuration; break;
                        case 'tech': buffs.rapid = buffDuration; break;
                        case 'retail': buffs.magnet = buffDuration; break;
                        case 'grocer': player.hp = Math.min(player.maxHp, player.hp + 50); break;
                    }
                    damageNumbers.push(new DamageText(player.worldX, player.worldY, s.label, '#f1c40f'));
                    playSound('powerup'); 
                    score += 500;
                    storeLocations.splice(i, 1);
                }
            }
        }

        function updateBuffUI() {
            const container = document.getElementById('active-buffs');
            container.innerHTML = '';
            if (buffs.speed > 0) container.innerHTML += `<div class="buff-item">‚ö° SPEED UP (${Math.ceil(buffs.speed/60)}s)</div>`;
            if (buffs.damage > 0) container.innerHTML += `<div class="buff-item">üí™ DAMAGE UP (${Math.ceil(buffs.damage/60)}s)</div>`;
            if (buffs.rapid > 0) container.innerHTML += `<div class="buff-item">üî´ RAPID FIRE (${Math.ceil(buffs.rapid/60)}s)</div>`;
            if (buffs.magnet > 0) container.innerHTML += `<div class="buff-item">üß≤ MAGNET (${Math.ceil(buffs.magnet/60)}s)</div>`;
        }

        function updatePowersList() {
            const list = document.getElementById('powers-list');
            list.innerHTML = ''; 
            possibleUpgrades.forEach(u => {
                if (u.count > 0) {
                    const div = document.createElement('div');
                    div.className = 'power-item';
                    const iconHtml = AbilityIcons[u.iconId] || '';
                    div.innerHTML = `<span class="power-icon">${iconHtml}</span> ${u.name} <span class="power-count">x${u.count}</span>`;
                    list.appendChild(div);
                }
            });
        }

        function selectUpgrade(index) {
            const c = currentUpgradeChoices[index];
            if (c) {
                c.apply();
                c.count++;
                updatePowersList();
                document.getElementById('upgrade-screen').style.display = 'none';
                gameState = 'PLAYING';
            }
        }

        function updateCardSelectionVisuals() {
            const cards = document.querySelectorAll('.card');
            cards.forEach((card, index) => {
                if (index === selectedUpgradeIndex) card.classList.add('selected');
                else card.classList.remove('selected');
            });
        }

        function levelUp() {
            playSound('levelup'); 
            gameState = 'LEVEL_UP';
            player.level++;
            player.xp = 0;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.3);
            document.getElementById('level-display').innerText = player.level + '.0';
            
            const screen = document.getElementById('upgrade-screen');
            const container = document.getElementById('cards-container');
            container.innerHTML = '';
            
            const shuffled = [...possibleUpgrades].sort(() => 0.5 - Math.random());
            currentUpgradeChoices = shuffled.slice(0, 3);
            selectedUpgradeIndex = 1;

            currentUpgradeChoices.forEach((c, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => selectUpgrade(index);
                card.onmouseenter = () => { selectedUpgradeIndex = index; updateCardSelectionVisuals(); };
                const iconHtml = AbilityIcons[c.iconId] || '';
                card.innerHTML = `<h3>${iconHtml} ${c.name}</h3><p>${c.desc}</p>`;
                container.appendChild(card);
            });
            
            updateCardSelectionVisuals();
            screen.style.display = 'flex';
        }

        function updateUI() {
            document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('xp-bar').style.width = (player.xp / player.xpToNextLevel * 100) + '%';
        }

        function draw() {
            const camX = player.worldX - canvas.width / 2;
            const camY = player.worldY - canvas.height / 2;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            if (screenShake > 0.1) {
                ctx.translate(Math.random() * screenShake - screenShake/2, Math.random() * screenShake - screenShake/2);
            }

            ctx.strokeStyle = '#2c2c36';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridOffsetX = player.worldX % 100;
            const gridOffsetY = player.worldY % 100;
            for (let x = -gridOffsetX; x < canvas.width; x += 100) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = -gridOffsetY; y < canvas.height; y += 100) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            const startCol = Math.floor(camX / TILE_SIZE);
            const endCol = startCol + (canvas.width / TILE_SIZE) + 1;
            const startRow = Math.floor(camY / TILE_SIZE);
            const endRow = startRow + (canvas.height / TILE_SIZE) + 1;

            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    const obs = getObstacleAt(c, r);
                    if (obs) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(obs.x - camX, obs.y - camY, OBSTACLE_SIZE, OBSTACLE_SIZE);
                        ctx.strokeStyle = '#444';
                        ctx.strokeRect(obs.x - camX, obs.y - camY, OBSTACLE_SIZE, OBSTACLE_SIZE);
                    }
                }
            }

            trail.forEach(t => {
                if (playerSprite.complete) {
                    ctx.globalAlpha = t.life / 20; 
                    ctx.drawImage(playerSprite, t.x - camX - player.size/2, t.y - camY - player.size/2, player.size, player.size);
                    ctx.globalAlpha = 1.0;
                }
            });

            magnetPickups.forEach(m => m.draw(ctx, camX, camY));
            piPickups.forEach(p => p.draw(ctx, camX, camY));
            storeLocations.forEach(h => h.draw(ctx, camX, camY));
            gems.forEach(g => g.draw(ctx, camX, camY));
            bullets.forEach(b => b.draw(ctx, camX, camY));
            enemies.forEach(e => e.draw(ctx, camX, camY));
            damageNumbers.forEach(d => d.draw(ctx, camX, camY));
            particles.forEach(p => p.draw(ctx, camX, camY));

            if (playerSprite.complete && playerSprite.naturalWidth !== 0) {
                ctx.drawImage(playerSprite, (canvas.width/2) - player.size/2 + player.recoilX, (canvas.height/2) - player.size/2 + player.recoilY, player.size, player.size);
            } else {
                ctx.fillStyle = '#676DFD';
                ctx.fillRect((canvas.width/2) - player.size/2 + player.recoilX, (canvas.height/2) - player.size/2 + player.recoilY, player.size, player.size);
            }
            ctx.restore();
        }

        generateWorldStores();

        function gameLoop() {
            if (gameState === 'PLAYING' && !isPaused) {
                update();
            }
            draw();
            if (isPaused) document.getElementById('pause-screen').style.display = 'flex';
            else document.getElementById('pause-screen').style.display = 'none';
            requestAnimationFrame(gameLoop);
        }

        gameLoop();

    </script>
</body>
</html>