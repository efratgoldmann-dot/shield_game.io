<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Placer.ai: Survivor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1e1e24;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 10px; left: 10px;
            pointer-events: none;
            z-index: 10;
            font-family: 'Courier New', monospace;
            background: #3E44C6;
            padding: 15px;
            border: 1px solid rgba(103, 109, 253, 0.4);
            border-radius: 4px;
            color: white;
        }
        .bar-container {
            width: 250px; height: 20px;
            background: #232B7F;
            border: 1px solid #676DFD;
            margin-bottom: 8px;
            position: relative;
        }
        .bar-fill {
            height: 100%; width: 0%;
            transition: width 0.2s;
        }
        #hp-bar { background-color: #BED2FF; width: 100%; } 
        #xp-bar { background-color: #FFB748; } 
        
        h1 { margin: 0 0 10px 0; font-size: 18px; text-shadow: 2px 2px 0 #000; letter-spacing: 2px; font-family: 'Courier New', monospace; font-weight: bold;}
        .label { font-size: 11px; color: white; text-transform: uppercase; letter-spacing: 1px; margin-top: 8px; }
        
        #powers-list {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .power-item {
            display: flex;
            align-items: center;
            background: rgba(40, 50, 100, 0.5);
            padding: 6px 10px;
            border-radius: 3px;
            width: fit-content;
            border-left: 2px solid #676DFD;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        .power-icon { margin-right: 8px; font-size: 16px; }
        .power-count { font-weight: bold; color: #fff; margin-left: 5px; }

        #active-buffs {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .buff-item {
            color: #f1c40f;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 0 0 5px rgba(241, 196, 15, 0.5);
            animation: pulse 1s infinite;
            font-family: 'Courier New', monospace;
        }

        #upgrade-screen {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(30, 30, 36, 0.95);
            z-index: 20;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .cards-container {
            display: flex; gap: 20px; margin-top: 20px;
            flex-wrap: wrap; justify-content: center;
        }
        .card {
            background: #2b2b36;
            border: 2px solid #444;
            width: 220px; padding: 25px;
            text-align: center; cursor: pointer;
            transition: all 0.2s;
            pointer-events: auto;
            position: relative;
            border-radius: 8px;
        }
        .card.selected, .card:hover {
            transform: translateY(-5px);
            background: #3a3a4a;
            border-color: #676DFD;
            box-shadow: 0 5px 20px rgba(103, 109, 253, 0.3);
        }
        .card .card-icon { font-size: 56px; line-height: 1; margin-bottom: 12px; display: block; text-align: center; }
        .card h3 { color: #676DFD; margin-top: 0; font-size: 18px; text-align: center; margin-bottom: 6px; }
        .card p { font-size: 13px; color: #ccc; line-height: 1.4; }
        
        #controls-hint {
            margin-top: 30px;
            color: #777;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #pause-screen {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 15;
            display: none; 
            align-items: center; justify-content: center;
        }
        #pause-text {
            font-size: 80px; color: white; font-weight: bold; letter-spacing: 5px; text-shadow: 0 0 20px #000;
        }

        #wave-warning {
            display: none; position: absolute; top: 20%; width: 100%;
            text-align: center; font-size: 40px; color: #e74c3c;
            font-weight: bold; text-shadow: 0 0 10px red; pointer-events: none;
            animation: pulse 0.5s infinite alternate;
            font-family: monospace;
        }
        @keyframes pulse { from { opacity: 1; } to { opacity: 0.5; } }

        #game-over {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; background: #3E44C6;
            padding: 50px; border: 2px solid #E5462C; z-index: 30;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            min-width: 400px;
        }
        #game-over h1 {
            color: #E5462C;
            font-size: 36px;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }
        #game-over p {
            color: white;
            font-size: 16px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        #game-over button {
            background: #BED2FF;
            color: #3E44C6;
            padding: 12px 40px;
            font-size: 18px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
        }
        #game-over button:hover {
            background: #ffffff;
        }
        #game-over #restart-hint {
            color: white;
            font-size: 12px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
        }
        #final-level {
            font-size: 48px;
            font-weight: bold;
            color: white;
            display: block;
            margin: 10px 0 10px 0;
        }
        
        .info-row {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: white;
            margin-top: 6px;
            letter-spacing: 1px;
        }
        .info-label {
            color: white;
        }
        button:not(#game-over button) {
            padding: 12px 24px; font-size: 16px; cursor: pointer;
            background: #676DFD; color: white; border: none; font-weight: bold; 
            margin-top: 20px; border-radius: 4px;
        }
        button:not(#game-over button):hover { background: #555ce0; }
        /* Mobile on-screen controls */
        #mobile-controls { position: fixed; left: 18px; bottom: 18px; width: 160px; height: 160px; z-index: 50; display: none; user-select: none; }
        .arrow-grid { position: relative; width: 100%; height: 100%; }
        .arrow-btn {
            position: absolute;
            width: 56px; height: 56px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            color: white; font-size: 28px; display: flex; align-items: center; justify-content: center;
            border: 2px solid rgba(255,255,255,0.06);
            box-shadow: 0 6px 18px rgba(0,0,0,0.6);
            touch-action: none;
        }
        .arrow-btn:active { background: rgba(103,109,253,0.95); }
        .arrow-up { left: 52px; top: 0; }
        .arrow-left { left: 0; top: 52px; }
        .arrow-right { right: 0; top: 52px; }
        .arrow-down { left: 52px; bottom: 0; }
        @media (max-width: 900px), (hover: none) {
            #mobile-controls { display: block; }
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>PLACER SURVIVOR V.<span id="level-display">1.0</span></h1>
        
        <div class="label">REVENUE</div>
        <div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div>
        
        <div class="label">ARR</div>
        <div class="bar-container"><div id="xp-bar" class="bar-fill"></div></div>
        
        <div class="info-row"><span class="info-label">Visits:</span> <span id="score-display">0</span></div>
        <div class="info-row"><span class="info-label">Uptime:</span> <span id="time-display">0:00</span></div>
        <div class="info-row" style="font-size: 11px; color: #777;"><span class="info-label">Lat/Long:</span> <span id="coord-display">0, 0</span></div>
        
        <div id="powers-list"></div>
        <div id="active-buffs"></div>
    </div>

    <div id="wave-warning">‚ö†Ô∏è SEASONAL TRAFFIC SPIKE DETECTED ‚ö†Ô∏è</div>

    <div id="pause-screen">
        <div id="pause-text">PAUSED</div>
    </div>

    <div id="upgrade-screen">
        <h1 style="font-size: 30px; color: white;">NEW METRIC UNLOCKED</h1>
        <p style="color: #aaa;">Select a feature to add to your dashboard</p>
        <div class="cards-container" id="cards-container"></div>
        <div id="controls-hint">Use ‚¨ÖÔ∏è ‚û°Ô∏è Arrows to move, ENTER to Select</div>
    </div>

    <div id="game-over">
        <h1>ANALYSIS FAILED</h1>
        <p>Market Landscape too volatile. Report Aborted.</p>
        <p style="font-size: 14px; margin-top: 20px;">Development Stage:</p>
        <span id="final-level">1.0</span>
        <button onclick="location.reload()">RESTART</button>
        <div id="restart-hint">Press ENTER to Restart</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Mobile arrow controls (visible on narrow / touch devices) -->
    <div id="mobile-controls" aria-hidden="true">
        <div class="arrow-grid">
            <div id="arrow-up" class="arrow-btn arrow-up">‚ñ≤</div>
            <div id="arrow-left" class="arrow-btn arrow-left">‚óÄ</div>
            <div id="arrow-right" class="arrow-btn arrow-right">‚ñ∂</div>
            <div id="arrow-down" class="arrow-btn arrow-down">‚ñº</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- ASSET LOADING ---
        const playerSprite = new Image(); playerSprite.src = 'player.png';
        const enemyNoiseSprite = new Image(); enemyNoiseSprite.src = 'Enemies/5508.png';
        const enemyNoiseSprite2 = new Image(); enemyNoiseSprite2.src = 'Enemies/5513.png';
        const enemyEliteSprite = new Image(); enemyEliteSprite.src = 'Enemies/5518.png';
            const enemy5520Sprite = new Image(); enemy5520Sprite.src = 'Enemies/5520.png';
        const enemy5526Sprite = new Image(); enemy5526Sprite.src = 'Enemies/5526.png';
        const magnetSprite = new Image(); magnetSprite.src = 'magnet.png';
        const piSprite = new Image(); piSprite.src = 'AbilityIcons/Pi.png';
        
        // Barrier sprites
        const barrierSprites = [
            (() => { const img = new Image(); img.src = 'barriers /1.png'; return img; })(),
            (() => { const img = new Image(); img.src = 'barriers /2.png'; return img; })(),
            (() => { const img = new Image(); img.src = 'barriers /3.png'; return img; })(),
            (() => { const img = new Image(); img.src = 'barriers /4.png'; return img; })(),
            (() => { const img = new Image(); img.src = 'barriers /6.png'; return img; })(),
            (() => { const img = new Image(); img.src = 'barriers /image 52.png'; return img; })()
        ];

        // --- BRAND DATA ---
        const storeData = [
            { file: 'locations/Starbucks.png', name: 'Starbucks', type: 'coffee', label: 'CAFFEINE RUSH' },
            { file: 'locations/Dunkin.png', name: 'Dunkin', type: 'coffee', label: 'SUGAR RUSH' },
            { file: 'locations/McDonalds.png', name: 'McDonalds', type: 'food', label: 'CALORIE SPIKE' },
            { file: 'locations/Burger King.png', name: 'Burger King', type: 'food', label: 'WHOPPER MIGHT' },
            { file: 'locations/KFC.png', name: 'KFC', type: 'food', label: 'CRISPY POWER' },
            { file: 'locations/Apple.png', name: 'Apple', type: 'tech', label: 'PROCESSOR UPGRADE' },
            { file: 'locations/Target.png', name: 'Target', type: 'retail', label: 'MARKET REACH' },
            { file: 'locations/Walmart.png', name: 'Walmart', type: 'retail', label: 'MARKET REACH' },
            { file: 'locations/7Eleven.png', name: '7-Eleven', type: 'grocer', label: 'RESTOCK' },
            { file: 'locations/Aldi.png', name: 'Aldi', type: 'grocer', label: 'RESTOCK' },
            { file: 'locations/GAP.png', name: 'GAP', type: 'grocer', label: 'RETAIL THERAPY' }
        ];

        let spritesLoaded = 0;
        const checkLoad = () => { spritesLoaded++; };
        playerSprite.onload = checkLoad;
        enemyNoiseSprite.onload = checkLoad;
        enemyNoiseSprite2.onload = checkLoad;
        enemyEliteSprite.onload = checkLoad;
            enemy5520Sprite.onload = checkLoad;
        enemy5526Sprite.onload = checkLoad;
        storeData.forEach(store => {
            store.img = new Image();
            store.img.src = store.file;
            store.img.onload = checkLoad;
        });
        piSprite.onload = checkLoad;

        // --- AUDIO ENGINE (8-BIT SYNTH) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        let musicTick = 0;
        const musicMelody = [130.81, 155.56, 174.61, 196.00]; 

        function playMusicNote(freq) {
            if (audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.015, audioCtx.currentTime); 
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.4);
        }

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            }
            else if (type === 'pickup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, now);
                osc.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            else if (type === 'powerup') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            }
            else if (type === 'magnet') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(600, now + 1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 1);
                osc.start(now);
                osc.stop(now + 1);
            }
            else if (type === 'levelup') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.setValueAtTime(554, now + 0.1);
                osc.frequency.setValueAtTime(659, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            }
        }

        // --- CONFIG & STATE ---

        function isInView(x, y) {
            const camX = player.worldX - canvas.width / 2;
            const camY = player.worldY - canvas.height / 2;
            return x > camX && x < camX + canvas.width && y > camY && y < camY + canvas.height;
        }

        function typeInView(type) {
            return storeLocations.some(s => s.type === type && isInView(s.x, s.y));
        }
        const TILE_SIZE = 400; 
        const OBSTACLE_SIZE = 120;
        
        let gameState = 'PLAYING';
        let isPaused = false; 
        let score = 0;
        let frame = 0;
        let timeSeconds = 0;
        let screenShake = 0; 
        
        let currentUpgradeChoices = [];
        let selectedUpgradeIndex = 0;

        const buffs = { speed: 0, damage: 0, rapid: 0, magnet: 0 };

        const player = {
            worldX: 0, worldY: 0,
            size: 40, speed: 2.88, 
            hp: 100, maxHp: 100,
            xp: 0, xpToNextLevel: 10, level: 1,
            fireRate: 55, 
            bulletSpeed: 5.04, 
            bulletDamage: 25,
            projectileCount: 1, piercing: 0,
            recoilX: 0, recoilY: 0,
            abilities: {
                newDataset: 1,
                trueTradeArea: 0,
                crossShoppingAnalytics: 0,
                voidAnalysis: 0,
                mobilePanel: 0,
                geoFencing: 0,
                forecasting: 0
            },
            shieldHP: 0,
            shieldMax: 0,
            ceasefireTimer: 0,
            techTimer: 0
        };

        const keys = {};
        let bullets = [];
        let enemies = [];
        let gems = [];
        let piPickups = [];
        let damageNumbers = [];
        let particles = [];
        let storeLocations = [];
        let magnetPickups = []; 
        let trail = []; 
        
        // Ability icons (now simple emojis representing each analytics ability)
        const AbilityIcons = {
            newDataset: 'üíæ',
            trueTradeArea: 'üåê',
            crossShoppingAnalytics: 'üîÄ',
            voidAnalysis: 'üî¶',
            mobilePanel: 'üì±',
            geoFencing: 'üõ°Ô∏è',
            forecasting: 'üîÆ'
        };

        // metadata describing each of the seven new abilities
        const abilityInfo = {
            newDataset: {
                id: 'newDataset',
                name: 'New Dataset',
                mechanic: 'Auto-fire nearest enemy',
                maxLevel: 5,
                getImprovement: lvl => `Fire rate +${Math.floor(lvl*10)}%, damage +${Math.floor(lvl*15)}%`
            },
            trueTradeArea: {
                id: 'trueTradeArea',
                name: 'True Trade Area',
                mechanic: 'Damage aura around you',
                maxLevel: 5,
                getImprovement: lvl => `Aura radius +${lvl*12}`
            },
            crossShoppingAnalytics: {
                id: 'crossShoppingAnalytics',
                name: 'Cross-Shopping Analytics',
                mechanic: 'Multi-shot spread',
                maxLevel: 5,
                getImprovement: lvl => `${1+lvl} projectiles`
            },
            voidAnalysis: {
                id: 'voidAnalysis',
                name: 'Void Analysis',
                mechanic: 'Piercing heavy attack',
                maxLevel: 5,
                getImprovement: lvl => `Pierce +${lvl*2}`
            },
            mobilePanel: {
                id: 'mobilePanel',
                name: 'Mobile Panel',
                mechanic: 'Speed & damaging trail',
                maxLevel: 5,
                getImprovement: lvl => `Speed +${lvl*5}%`
            },
            geoFencing: {
                id: 'geoFencing',
                name: 'Geo-Fencing',
                mechanic: 'Regenerating shield',
                maxLevel: 5,
                getImprovement: lvl => `Shield strength +${lvl*50}`
            },
            forecasting: {
                id: 'forecasting',
                name: 'Forecasting',
                mechanic: 'Auto-targeting drone',
                maxLevel: 5,
                getImprovement: lvl => `${lvl} drone(s)`
            }
        };

        // additional collections used by the new abilities
        let drones = [];
        let voidBeams = [];

        function generateWorldStores() {
            for(let i=0; i<60; i++) {
                addStore();
            }
        }

        function addStore() {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 10000 + 500;
            // pick a random brand but avoid duplicates of that type in view
            let attempts = 0;
            let chosen;
            while(attempts < 5) {
                const candidate = storeData[Math.floor(Math.random() * storeData.length)];
                if (!typeInView(candidate.type)) { chosen = candidate; break; }
                attempts++;
            }
            if (!chosen) chosen = storeData[Math.floor(Math.random() * storeData.length)];
            storeLocations.push(new StoreLocation(
                player.worldX + Math.cos(angle) * dist,
                player.worldY + Math.sin(angle) * dist,
                chosen // pass chosen to constructor? or set after
            ));
        }

        function ensureStores() {
            // keep at least 40 stores in play by spawning new ones as needed
            while (storeLocations.length < 40) {
                addStore();
            }
        }

        window.addEventListener('keydown', e => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (e.code === 'Space' && gameState === 'PLAYING') {
                isPaused = !isPaused;
                document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
            }
            if (gameState === 'GAME_OVER' && e.key === 'Enter') location.reload();
            if (gameState === 'LEVEL_UP') {
                if (e.key === 'ArrowLeft') { selectedUpgradeIndex = (selectedUpgradeIndex - 1 + 3) % 3; updateCardSelectionVisuals(); } 
                else if (e.key === 'ArrowRight') { selectedUpgradeIndex = (selectedUpgradeIndex + 1) % 3; updateCardSelectionVisuals(); } 
                else if (e.key === 'Enter') selectUpgrade(selectedUpgradeIndex);
                return;
            }
            keys[e.key] = true;
        });
        window.addEventListener('keyup', e => keys[e.key] = false);

        // Mobile / touch control setup: map on-screen arrows to arrow key states
        function addPointerHandler(elem, keyName) {
            if (!elem) return;
            const setDown = (ev) => { ev.preventDefault(); keys[keyName] = true; };
            const setUp = (ev) => { ev.preventDefault(); keys[keyName] = false; };
            elem.addEventListener('pointerdown', setDown);
            elem.addEventListener('pointerup', setUp);
            elem.addEventListener('pointercancel', setUp);
            elem.addEventListener('pointerleave', setUp);
            // fallback for older touch events
            elem.addEventListener('touchstart', setDown, {passive:false});
            elem.addEventListener('touchend', setUp);
            elem.addEventListener('touchcancel', setUp);
            // also support mouse events
            elem.addEventListener('mousedown', setDown);
            elem.addEventListener('mouseup', setUp);
        }

        function setupMobileControls() {
            const up = document.getElementById('arrow-up');
            const left = document.getElementById('arrow-left');
            const right = document.getElementById('arrow-right');
            const down = document.getElementById('arrow-down');
            addPointerHandler(up, 'ArrowUp');
            addPointerHandler(left, 'ArrowLeft');
            addPointerHandler(right, 'ArrowRight');
            addPointerHandler(down, 'ArrowDown');
            // prevent the browser from panning on touch drags
            const container = document.getElementById('mobile-controls');
            if (container) container.style.touchAction = 'none';
        }

        // initialize mobile controls (visible via CSS on touch/narrow screens)
        setupMobileControls();

        function getObstacleAt(gridX, gridY) {
            const seed = Math.sin(gridX * 12.9898 + gridY * 78.233) * 43758.5453;
            const rand = seed - Math.floor(seed);
            if (rand > 0.8) {
                const spriteIndex = Math.floor(rand * 10) % barrierSprites.length;
                return { x: gridX * TILE_SIZE + (rand * 100), y: gridY * TILE_SIZE + (rand * 200), type: 'silo', spriteIndex: spriteIndex };
            }
            return null;
        }

        function checkWallCollision(x, y, radius) {
            const gx = Math.floor(x / TILE_SIZE);
            const gy = Math.floor(y / TILE_SIZE);
            for (let i = gx - 1; i <= gx + 1; i++) {
                for (let j = gy - 1; j <= gy + 1; j++) {
                    const obs = getObstacleAt(i, j);
                    if (obs) {
                        const closestX = Math.max(obs.x, Math.min(x, obs.x + OBSTACLE_SIZE));
                        const closestY = Math.max(obs.y, Math.min(y, obs.y + OBSTACLE_SIZE));
                        const dx = x - closestX;
                        const dy = y - closestY;
                        if ((dx * dx + dy * dy) < (radius * radius)) return true;
                    }
                }
            }
            return false;
        }
        
        function explodeAllEnemies(originX, originY) {
            if (enemies.length === 0) return;
            let totalScore = 0;
            enemies.forEach(e => {
                totalScore += e.xpValue || 10;
                for (let k = 0; k < 20; k++) particles.push(new Particle(e.x, e.y, '#e74c3c'));
                gems.push(new Gem(e.x, e.y, e.xpValue || 5, '#f1c40f'));
            });
            enemies = [];
            score += totalScore;
            document.getElementById('score-display').innerText = score;
            damageNumbers.push(new DamageText(originX, originY, 'œÄ NUKED', '#f1c40f'));
            playSound('levelup');
        }
        
        class MagnetPickup {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = 30; this.bobOffset = 0;
            }
            update() { this.bobOffset = Math.sin(frame * 0.1) * 5; }
            draw(ctx, camX, camY) {
                if (magnetSprite.complete && magnetSprite.naturalWidth !== 0) {
                    ctx.drawImage(magnetSprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    const x = this.x - camX; const y = this.y - camY + this.bobOffset;
                    ctx.fillStyle = '#ecf0f1';
                    ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.arc(x - 10, y + 5, 8, 0, Math.PI * 2); ctx.arc(x + 10, y + 5, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#3498db'; ctx.font = '10px Arial'; ctx.fillText("DATA SYNC", x - 25, y - 15);
                }
            }
        }

        class PiPickup {
            constructor(x, y) {
                this.x = x; this.y = y;
                this.size = 34; this.bobOffset = 0;
            }
            update() { this.bobOffset = Math.sin(frame * 0.12) * 6; }
            draw(ctx, camX, camY) {
                if (piSprite.complete && piSprite.naturalWidth !== 0) {
                    ctx.drawImage(piSprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    const x = this.x - camX; const y = this.y - camY + this.bobOffset;
                    ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.font = '16px Arial'; ctx.fillText('œÄ', x-6, y+6);
                }
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = (Math.random() * 5 + 2) * 0.72; 
                this.dx = Math.cos(angle) * speed;
                this.dy = Math.sin(angle) * speed;
                this.life = 60; this.size = Math.random() * 6 + 4; 
            }
            update() {
                this.x += this.dx; this.y += this.dy;
                this.dx *= 0.95; this.dy *= 0.95;
                this.life--; this.size *= 0.96; 
            }
            draw(ctx, camX, camY) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - camX, this.y - camY, this.size, this.size);
            }
        }

        class StoreLocation {
            // storeObj optional allows caller to force a particular brand
            constructor(x, y, storeObj) {
                this.x = x; this.y = y;
                this.size = 75; 
                this.bobOffset = 0;
                const randomStore = storeObj || storeData[Math.floor(Math.random() * storeData.length)];
                this.sprite = randomStore.img;
                this.label = randomStore.label;
                this.name = randomStore.name;
                this.type = randomStore.type;
            }
            update() { this.bobOffset = Math.sin(frame * 0.1) * 5; }
            draw(ctx, camX, camY) {
                if (this.sprite && this.sprite.complete) {
                     ctx.drawImage(this.sprite, this.x - camX - this.size/2, this.y - camY - this.size/2 + this.bobOffset, this.size, this.size);
                } else {
                    ctx.fillStyle = '#2ecc71';
                    ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY + this.bobOffset, 25, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        class Bullet {
            constructor(x, y, targetX, targetY, angleOffset = 0) {
                this.x = x; this.y = y;
                const angle = Math.atan2(targetY - y, targetX - x) + angleOffset;
                this.dx = Math.cos(angle) * player.bulletSpeed;
                this.dy = Math.sin(angle) * player.bulletSpeed;
                this.radius = 5; this.life = 100;
                this.pierce = player.piercing;
                this.hitList = [];
                playSound('shoot'); 
            }
            update() {
                this.x += this.dx; this.y += this.dy; this.life--;
                if (checkWallCollision(this.x, this.y, 2)) this.life = 0;
            }
            draw(ctx, camX, camY) {
                let color = '#676DFD';
                if (buffs.damage > 0) color = '#e74c3c'; 
                if (buffs.rapid > 0) color = '#f1c40f'; 

                if (this.type === 'newDataset') {
                    color = '#00f';
                    if (this.visualLevel >= 5) {
                        ctx.strokeStyle = 'cyan';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(this.x - camX, this.y - camY);
                        ctx.lineTo(this.x - camX - this.dx*2, this.y - camY - this.dy*2);
                        ctx.stroke();
                    } else if (this.visualLevel >= 3) {
                        ctx.strokeStyle = 'cyan';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5,5]);
                        ctx.beginPath();
                        ctx.moveTo(this.x - camX, this.y - camY);
                        ctx.lineTo(this.x - camX - this.dx*1.5, this.y - camY - this.dy*1.5);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x - camX, this.y - camY, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'void') {
                    color = '#a020f0';
                    if (this.visualLevel >= 5) {
                        ctx.fillStyle = color;
                        ctx.fillRect(this.x - camX - 4, this.y - camY - 4, 8, 8);
                    } else if (this.visualLevel >= 3) {
                        ctx.fillStyle = color;
                        ctx.fillRect(this.x - camX - 3, this.y - camY - 3, 6, 6);
                    } else {
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x - camX, this.y - camY, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (this.type === 'tech') {
                    // highly destructive visual
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 6;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(this.x - camX, this.y - camY);
                    ctx.lineTo(this.x - camX - this.dx*3, this.y - camY - this.dy*3);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                } else if (this.type === 'drone') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - camX - 2, this.y - camY - 2, 4, 4);
                } else {
                    if (this.pierce > 0) {
                        ctx.shadowBlur = 10; ctx.shadowColor = color;
                        ctx.fillStyle = '#fff';
                        ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY, this.radius + 2, 0, Math.PI * 2); ctx.fill();
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.fillStyle = color;
                        ctx.beginPath(); ctx.arc(this.x - camX, this.y - camY, this.radius, 0, Math.PI * 2); ctx.fill();
                    }
                }
            }
        }

        class Enemy {
            constructor(isElite = false, isBoss = false, variant = null) {
                this.lastRepelFrame = 0; // used to throttle pushback
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(canvas.width, canvas.height) / 2 + 100;
                this.x = player.worldX + Math.cos(angle) * dist;
                this.y = player.worldY + Math.sin(angle) * dist;
                this.vx = 0;
                this.vy = 0;
                const difficultyMultiplier = 1 + (timeSeconds / 120);
                this.isElite = isElite;
                this.isBoss = isBoss;
                this.variant = variant;

                // special variant using 5520.png
                if (this.variant === '5520') {
                    this.size = 50;
                    this.speed = (0.9 + (player.level * 0.006)) * difficultyMultiplier;
                    this.hp = (40 + (player.level * 10)) * difficultyMultiplier;
                    this.color = '#22aacc';
                    this.xpValue = 15;
                    this.sprite = enemy5520Sprite;
                    this.mass = 1.2;
                } else if (this.variant === '5526') {
                    // second special variant using 5526.png
                    this.size = 80;
                    this.speed = (0.6 + (player.level * 0.004)) * difficultyMultiplier;
                    this.hp = (120 + (player.level * 30)) * difficultyMultiplier;
                    this.color = '#aa22cc';
                    this.xpValue = 80;
                    this.sprite = enemy5526Sprite;
                    this.mass = 3.0;
                } else if (this.isBoss) {
                    this.size = 140; // BIGGEST
                    this.speed = (0.5 + (player.level * 0.002)) * difficultyMultiplier; 
                    this.hp = (500 + (player.level * 100)) * difficultyMultiplier;
                    this.color = '#f1c40f';
                    this.xpValue = 1000; // BIG PRICE
                    this.sprite = enemyNoiseSprite2; // Error1.png
                    this.mass = 8.0; 
                } else if (this.isElite) {
                    this.size = 65; 
                    this.speed = (0.65 + (player.level * 0.003)) * difficultyMultiplier; 
                    this.hp = (100 + (player.level * 20)) * difficultyMultiplier;
                    this.color = '#e74c3c';
                    this.xpValue = 50; 
                    this.sprite = enemyEliteSprite;
                    this.mass = 2.5; 
                } else {
                    this.size = 30; 
                    this.speed = (0.72 + (player.level * 0.007)) * difficultyMultiplier; 
                    this.hp = (20 + (player.level * 5)) * difficultyMultiplier;
                    this.color = '#7f8c8d'; 
                    this.xpValue = 5; 
                    this.sprite = enemyNoiseSprite; 
                    this.mass = 1; 
                }
                this.maxHp = this.hp;
            }
            update() {
                const angle = Math.atan2(player.worldY - this.y, player.worldX - this.x);
                const nextX = this.x + Math.cos(angle) * this.speed + this.vx;
                const nextY = this.y + Math.sin(angle) * this.speed + this.vy;
                if (!checkWallCollision(nextX, this.y, this.size/2)) this.x = nextX;
                if (!checkWallCollision(this.x, nextY, this.size/2)) this.y = nextY;
                this.vx *= 0.85;
                this.vy *= 0.85;
            }
            draw(ctx, camX, camY) {
                if (Math.abs(this.x - player.worldX) > canvas.width || Math.abs(this.y - player.worldY) > canvas.height) return;
                let sprite = this.sprite;
                if (sprite.complete && sprite.naturalWidth !== 0) {
                     ctx.drawImage(sprite, this.x - camX - this.size/2, this.y - camY - this.size/2, this.size, this.size);
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x - camX - this.size/2, this.y - camY - this.size/2, this.size, this.size);
                }
            }
        }

        class Gem {
            constructor(x, y, value, color) {
                this.x = x; this.y = y; this.value = value; this.size = 8;
                this.color = color || '#3498db';
                if (value > 10) this.size = 12; 
                if (value >= 1000) this.size = 30; // Boss gem size
                this.beingSucked = false; 
            }
            draw(ctx, camX, camY) {
                if (this.beingSucked) ctx.fillStyle = '#fff';
                else ctx.fillStyle = this.color;
                
                ctx.beginPath();
                ctx.moveTo(this.x - camX, this.y - camY - this.size);
                ctx.lineTo(this.x - camX + this.size, this.y - camY);
                ctx.lineTo(this.x - camX, this.y - camY + this.size);
                ctx.lineTo(this.x - camX - this.size, this.y - camY);
                ctx.fill();
            }
        }

        class DamageText {
            constructor(x, y, text, color) {
                this.x = x; this.y = y; this.text = text; 
                this.life = 180; 
                this.dy = -0.21; 
                this.color = color || '#676DFD';
            }
            update() { this.y += this.dy; this.life--; }
            draw(ctx, camX, camY) {
                ctx.fillStyle = this.color; ctx.font = 'bold 16px Arial';
                ctx.fillText(this.text, this.x - camX, this.y - camY);
            }
        }

        // small orbiting drone used by forecasting ability
        class Drone {
            constructor(angle) { this.angle = angle; }
            update() { this.angle += 0.03; }
            draw(ctx, camX, camY) {
                const x = player.worldX + Math.cos(this.angle) * 80 - camX;
                const y = player.worldY + Math.sin(this.angle) * 80 - camY;
                ctx.fillStyle = '#fff';
                ctx.fillRect(x-5, y-5, 10, 10);
            }
            getPosition() {
                return {
                    x: player.worldX + Math.cos(this.angle) * 80,
                    y: player.worldY + Math.sin(this.angle) * 80
                };
            }
        }

        // beam used for void analysis ability
        class VoidBeam {
            constructor(angle, level) {
                this.x = player.worldX;
                this.y = player.worldY;
                this.angle = angle;
                this.life = 60;
                this.level = level;
                this.hitEnemies = new Set();
            }
            update() {
                this.life--;
            }
            draw(ctx, camX, camY) {
                const len = Math.max(canvas.width, canvas.height) * 1.5;
                const endX = this.x + Math.cos(this.angle) * len;
                const endY = this.y + Math.sin(this.angle) * len;
                ctx.save();
                if (this.level >= 5) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 8;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#a020f0';
                } else if (this.level >= 3) {
                    ctx.strokeStyle = '#a020f0';
                    ctx.lineWidth = 6;
                } else {
                    ctx.strokeStyle = '#a020f0';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                }
                ctx.beginPath();
                ctx.moveTo(this.x - camX, this.y - camY);
                ctx.lineTo(endX - camX, endY - camY);
                ctx.stroke();
                ctx.restore();
                ctx.setLineDash([]);
            }
            hits(enemy) {
                const vx = Math.cos(this.angle);
                const vy = Math.sin(this.angle);
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const proj = dx*vx + dy*vy;
                if (proj < 0) return false;
                const perpDist = Math.abs(dx*vy - dy*vx);
                return perpDist < 20;
            }
        }

        function spawnManager() {
            // if ceasefire active, skip spawning
            if (player.ceasefireTimer > 0) return;
            // enemies start off sparse and then slowly pick up pace as time passes
            // base interval is high, then reduced by a small amount every 10 seconds and per level
            const baseInterval = 150; // roughly 2.5 seconds at 60fps
            const timeFactor = Math.floor(timeSeconds / 10);
            const levelFactor = player.level * 2;
            let spawnRate = Math.max(20, baseInterval - timeFactor - levelFactor);
            
            if (frame % spawnRate === 0) {
                const rand = Math.random();
                let isElite = rand < 0.01;
                let isBoss = rand < 0.002; // MOST RARE
                // small chance to spawn the new 5520 or 5526 variants
                let variantRoll = Math.random();
                let variant = null;
                if (variantRoll < 0.025) variant = '5520';
                else if (variantRoll < 0.04) variant = '5526';
                enemies.push(new Enemy(isElite, isBoss, variant));
            }
            
            if (frame % 2500 === 0 && frame > 500) {
                 const angle = Math.random() * Math.PI * 2;
                 const dist = 500; 
                 magnetPickups.push(new MagnetPickup(
                     player.worldX + Math.cos(angle) * dist,
                     player.worldY + Math.sin(angle) * dist
                 ));
            }

            if (frame % 2500 === 0 && frame > 100) triggerHorde();
            if (frame % 60 === 0) enemies = enemies.filter(e => Math.hypot(e.x - player.worldX, e.y - player.worldY) < 2500);
        }

        function triggerHorde() {
            const messages = ["‚ö†Ô∏è SEASONAL TRAFFIC SPIKE ‚ö†Ô∏è", "‚ö†Ô∏è BLACK FRIDAY CROWDS ‚ö†Ô∏è", "‚ö†Ô∏è COMPETITOR GRAND OPENING ‚ö†Ô∏è", "‚ö†Ô∏è VIRAL TREND DETECTED ‚ö†Ô∏è"];
            const msg = messages[Math.floor(Math.random() * messages.length)];
            const warning = document.getElementById('wave-warning');
            warning.innerText = msg;
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 3000);
            const count = 20 + player.level;
            for(let i=0; i<count; i++) {
                setTimeout(() => {
                    const isElite = Math.random() < 0.05;
                    const vr = Math.random();
                    const variant = vr < 0.02 ? '5520' : (vr < 0.035 ? '5526' : null);
                    enemies.push(new Enemy(isElite, false, variant));
                }, i * 70);
            }
        }

        function update() {
            if (frame % 33 === 0) { 
                playMusicNote(musicMelody[musicTick % musicMelody.length]);
                musicTick++;
            }

            if (frame % 60 === 0) {
                timeSeconds++;
                const m = Math.floor(timeSeconds/60);
                const s = timeSeconds%60;
                document.getElementById('time-display').innerText = `${m}:${s<10?'0'+s:s}`;
                document.getElementById('coord-display').innerText = `${Math.floor(player.worldX)}, ${Math.floor(player.worldY)}`;
            }
            if (player.ceasefireTimer > 0) player.ceasefireTimer--;
            if (player.techTimer > 0) player.techTimer--;

            for (const key in buffs) {
                if (buffs[key] > 0) buffs[key]--;
            }
            updateBuffUI();

            if (screenShake > 0) screenShake *= 0.9;
            player.recoilX *= 0.8;
            player.recoilY *= 0.8;

            // shield regeneration (and repulsion effect)
            if (player.abilities.geoFencing > 0) {
                if (player.shieldMax === 0) player.shieldMax = 50 * player.abilities.geoFencing;
                if (player.shieldHP < player.shieldMax) {
                    player.shieldHP += 0.1;
                    if (player.shieldHP > player.shieldMax) player.shieldHP = player.shieldMax;
                }
                if (player.shieldHP > 0) {
                    // push nearby enemies outward from the shield, but only occasionally and weakly
                    enemies.forEach(e => {
                        const d = Math.hypot(e.x - player.worldX, e.y - player.worldY);
                        const shieldRadius = player.size + 30;
                        if (d < shieldRadius && d > 0 && frame - e.lastRepelFrame > 20) {
                            const ang = Math.atan2(e.y - player.worldY, e.x - player.worldX);
                            const push = 0.15; // much weaker
                            e.vx += Math.cos(ang) * push;
                            e.vy += Math.sin(ang) * push;
                            e.lastRepelFrame = frame;
                        }
                    });
                }
            }

            if (frame % 5 === 0 && player.speed > 2.5) { 
                const lvl = player.abilities.mobilePanel;
                let color = '#3498db';
                let dmg = 0;
                if (lvl > 0) {
                    dmg = lvl * 0.5;
                    if (lvl >= 5) color = '#e74c3c';
                    else if (lvl >= 3) color = '#f1c40f';
                }
                trail.push({x: player.worldX, y: player.worldY, life: 15, color, damage: dmg});
            }
            for(let i = trail.length - 1; i >= 0; i--) {
                trail[i].life--;
                if(trail[i].life <= 0) trail.splice(i, 1);
            }

            let currentSpeed = player.speed;
            if (buffs.speed > 0) currentSpeed *= 1.5; 
            if (player.abilities.mobilePanel > 0) currentSpeed *= 1 + (0.05 * player.abilities.mobilePanel);

            let dx = 0, dy = 0;
            if (keys['ArrowUp'] || keys['w']) dy = -currentSpeed;
            if (keys['ArrowDown'] || keys['s']) dy = currentSpeed;
            if (keys['ArrowLeft'] || keys['a']) dx = -currentSpeed;
            if (keys['ArrowRight'] || keys['d']) dx = currentSpeed;

            if (dx !== 0 || dy !== 0) {
                if (!checkWallCollision(player.worldX + dx, player.worldY, player.size/3)) player.worldX += dx;
                if (!checkWallCollision(player.worldX, player.worldY + dy, player.size/3)) player.worldY += dy;
            }

            let currentFireRate = player.fireRate;
            if (buffs.rapid > 0) currentFireRate = Math.max(5, Math.floor(currentFireRate * 0.5)); 
            if (player.abilities.newDataset > 0) currentFireRate = Math.max(3, currentFireRate / (1 + 0.1 * player.abilities.newDataset));

            if (frame % Math.floor(currentFireRate) === 0) {
                let nearest = null; let minDist = Infinity;
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - player.worldX, e.y - player.worldY);
                    if (dist < minDist) { minDist = dist; nearest = e; }
                });

                if (nearest && minDist < 700) {
                    const shootAngle = Math.atan2(nearest.y - player.worldY, nearest.x - player.worldX);
                    player.recoilX = -Math.cos(shootAngle) * 8;
                    player.recoilY = -Math.sin(shootAngle) * 8;

                    const lvlNew = player.abilities.newDataset;
                    const multiLvl = player.abilities.crossShoppingAnalytics;
                    const voidLvl = player.abilities.voidAnalysis;

                    let angleOffsets = [0];
                    if (multiLvl >= 1) angleOffsets.push(0.2, -0.2);
                    if (multiLvl >= 3) angleOffsets.push(0.4, -0.4);
                    if (multiLvl >= 5) {
                        angleOffsets = [];
                        for (let a = 0; a < 12; a++) angleOffsets.push((a/12)*Math.PI*2);
                    }

                    angleOffsets.forEach(offset => {
                        const b = new Bullet(player.worldX, player.worldY, nearest.x, nearest.y, offset);
                        if (player.techTimer > 0) {
                            // tech overdrive: lethal
                            b.damageOverride = 999999;
                            b.type = 'tech';
                        } else {
                            b.damageOverride = player.bulletDamage * (1 + 0.15 * lvlNew);
                            b.visualLevel = lvlNew;
                            b.type = 'newDataset';
                            if (voidLvl > 0) { b.pierce = voidLvl * 2; b.type = voidLvl > 0 ? 'void' : 'newDataset'; b.visualLevel = voidLvl; }
                        }
                        bullets.push(b);
                    });
                }
            }

            // occasional void beam
            if (player.abilities.voidAnalysis > 0 && frame % 300 === 0) {
                const angle = Math.random() * Math.PI * 2;
                voidBeams.push(new VoidBeam(angle, player.abilities.voidAnalysis));
            }

            bullets.forEach((b, i) => {
                b.update();
                if (b.life <= 0) bullets.splice(i, 1);
            });
            // update and remove void beams
            voidBeams.forEach((vb, i) => {
                vb.update();
                enemies.forEach(e => {
                    if (!vb.hitEnemies.has(e) && vb.hits(e)) {
                        e.hp -= 50;
                        vb.hitEnemies.add(e);
                    }
                });
                if (vb.life <= 0) voidBeams.splice(i, 1);
            });

            enemies.forEach(e => e.update());
            damageNumbers.forEach((d, i) => {
                d.update();
                if (d.life <= 0) damageNumbers.splice(i, 1);
            });
            particles.forEach((p, i) => {
                p.update();
                if (p.life <= 0) particles.splice(i, 1);
            });
            storeLocations.forEach((h, i) => { h.update(); });
            magnetPickups.forEach((m, i) => { m.update(); });

            spawnManager();
            checkCollisions();

            // make sure there are always some store locations available
            if (frame % 600 === 0) ensureStores();

            // aura damage + repulsion from True Trade Area
            if (player.abilities.trueTradeArea > 0) {
                const radius = player.abilities.trueTradeArea * 60;
                enemies.forEach(e => {
                    const dx = e.x - player.worldX;
                    const dy = e.y - player.worldY;
                    const d = Math.hypot(dx, dy);
                    if (d < radius) {
                        e.hp -= 0.2;
                        if (d > 0 && frame - e.lastRepelFrame > 15) {
                            const push = 0.1; // lighter effect
                            e.vx += (dx / d) * push;
                            e.vy += (dy / d) * push;
                            e.lastRepelFrame = frame;
                        }
                    }
                });
            }

            // drone management
            if (player.abilities.forecasting > 0) {
                const needed = player.abilities.forecasting >= 3 ? 2 : 1;
                while (drones.length < needed) drones.push(new Drone(Math.random()*Math.PI*2));
                while (drones.length > needed) drones.pop();
                drones.forEach(d=> d.update());
                if (frame % 30 === 0) {
                    drones.forEach(d=> {
                        let target = null; let minD = Infinity;
                        enemies.forEach(e => {
                            const dist = Math.hypot(e.x - player.worldX, e.y - player.worldY);
                            if (dist < minD) { minD = dist; target = e; }
                        });
                        if (target) {
                            const pos = d.getPosition();
                            const db = new Bullet(pos.x, pos.y, target.x, target.y);
                            db.type = 'drone';
                            bullets.push(db);
                        }
                    });
                }
            }

            updateUI();
            frame++;
        }

        function checkCollisions() {
            // bullets hitting enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                let currentDamage = b.damageOverride || player.bulletDamage;
                if (buffs.damage > 0) currentDamage *= 2;
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.hitList.includes(e)) continue;
                    if (Math.hypot(b.x - e.x, b.y - e.y) < e.size) {
                        e.hp -= currentDamage;
                        const pushForce = 8;
                        const angle = Math.atan2(e.y - b.y, e.x - b.x);
                        e.vx += Math.cos(angle) * (pushForce / e.mass);
                        e.vy += Math.sin(angle) * (pushForce / e.mass);
                        b.hitList.push(e);
                        damageNumbers.push(new DamageText(e.x, e.y, Math.floor(currentDamage)));
                        playSound('hit');
                        if (e.hp <= 0) {
                            let gemColor = '#3498db';
                            if (e.isElite) gemColor = '#e74c3c';
                            if (e.isBoss) gemColor = '#f1c40f';
                            gems.push(new Gem(e.x, e.y, e.xpValue, gemColor));
                            if (Math.random() < 0.01) { // slightly less rare
                                // only spawn if no pi already visible
                                if (!piPickups.some(p => isInView(p.x, p.y))) {
                                    piPickups.push(new PiPickup(e.x, e.y));
                                }
                            }
                            enemies.splice(j, 1);
                            score += e.xpValue;
                            document.getElementById('score-display').innerText = score;
                        }
                        if (b.pierce > 0) b.pierce--;
                        else { hit = true; break; }
                    }
                }
                if (hit) bullets.splice(i, 1);
            }

            // trail damage from mobile panel
            if (player.abilities.mobilePanel > 0) {
                for (let ti = trail.length - 1; ti >= 0; ti--) {
                    const t = trail[ti];
                    enemies.forEach(e => {
                        if (Math.hypot(e.x - t.x, e.y - t.y) < player.size/2) {
                            e.hp -= t.damage || 0;
                        }
                    });
                }
            }

            enemies.forEach(e => {
                if (Math.hypot(player.worldX - e.x, player.worldY - e.y) < (player.size/2 + e.size/2)) {
                    const dmg = e.isBoss ? 5.0 : (e.isElite ? 2.0 : 0.5);
                    if (player.abilities.geoFencing > 0 && player.shieldHP > 0) {
                        player.shieldHP -= dmg;
                        if (player.shieldHP <= 0) {
                            enemies.forEach(en => {
                                const ang = Math.atan2(en.y - player.worldY, en.x - player.worldX);
                                en.vx += Math.cos(ang) * 5;
                                en.vy += Math.sin(ang) * 5;
                            });
                        }
                    } else {
                        player.hp -= dmg;
                    }
                    screenShake = 12;
                    for (let k = 0; k < 15; k++) { particles.push(new Particle(player.worldX, player.worldY, '#676DFD')); }
                    if (frame % 10 === 0) playSound('hit');
                    if (player.hp <= 0) {
                        gameState = 'GAME_OVER';
                        document.getElementById('game-over').style.display = 'block';
                        document.getElementById('final-level').innerText = player.level + '.0';
                    }
                }
            });

            let magnetRange = 150;
            if (buffs.magnet > 0) magnetRange = 500; 

            for (let i = gems.length - 1; i >= 0; i--) {
                const g = gems[i];
                const dist = Math.hypot(player.worldX - g.x, player.worldY - g.y);
                
                if (g.beingSucked) {
                    g.x += (player.worldX - g.x) * 0.057; 
                    g.y += (player.worldY - g.y) * 0.057;
                } else if (dist < magnetRange) { 
                    const magSpeed = buffs.magnet > 0 ? 0.21 : 0.108; 
                    g.x += (player.worldX - g.x) * magSpeed; 
                    g.y += (player.worldY - g.y) * magSpeed; 
                }

                if (dist < 30) { 
                    player.xp += g.value;
                    gems.splice(i, 1);
                    playSound('pickup'); 
                    if (player.xp >= player.xpToNextLevel) levelUp();
                }
            }

            for (let i = magnetPickups.length - 1; i >= 0; i--) {
                const m = magnetPickups[i];
                if (Math.hypot(player.worldX - m.x, player.worldY - m.y) < (player.size/2 + m.size/2)) {
                    damageNumbers.push(new DamageText(player.worldX, player.worldY, "DATA SYNC INITIATED", '#3498db'));
                    gems.forEach(g => g.beingSucked = true);
                    playSound('magnet'); 
                    magnetPickups.splice(i, 1);
                }
            }

            for (let i = piPickups.length - 1; i >= 0; i--) {
                const p = piPickups[i];
                if (Math.hypot(player.worldX - p.x, player.worldY - p.y) < (player.size/2 + p.size/2)) {
                    explodeAllEnemies(player.worldX, player.worldY);
                    playSound('powerup');
                    player.ceasefireTimer = 500; // ~8 seconds of no new enemies
                    piPickups.splice(i, 1);
                }
            }

            for (let i = storeLocations.length - 1; i >= 0; i--) {
                const s = storeLocations[i];
                if (Math.hypot(player.worldX - s.x, player.worldY - s.y) < (player.size/2 + s.size/2)) {
                    const buffDuration = 600; 
                    switch(s.type) {
                        case 'coffee': buffs.speed = buffDuration; break;
                        case 'food': buffs.damage = buffDuration; break;
                        case 'tech':
                            // special lethal tech buff
                            player.techTimer = buffDuration;
                            break;
                        case 'retail': buffs.magnet = buffDuration; break;
                        case 'grocer': player.hp = Math.min(player.maxHp, player.hp + 50); break;
                    }
                    damageNumbers.push(new DamageText(player.worldX, player.worldY, s.label, '#f1c40f'));
                    playSound('powerup'); 
                    score += 500;
                    storeLocations.splice(i, 1);
                }
            }
        }

        function updateBuffUI() {
            const container = document.getElementById('active-buffs');
            container.innerHTML = '';
            if (buffs.speed > 0) container.innerHTML += `<div class="buff-item">‚ö° SPEED UP (${Math.ceil(buffs.speed/60)}s)</div>`;
            if (buffs.damage > 0) container.innerHTML += `<div class="buff-item">üí™ DAMAGE UP (${Math.ceil(buffs.damage/60)}s)</div>`;
            if (buffs.rapid > 0) container.innerHTML += `<div class="buff-item">üî´ RAPID FIRE (${Math.ceil(buffs.rapid/60)}s)</div>`;
            if (player.techTimer > 0) container.innerHTML += `<div class="buff-item">üí• TECH OVERDRIVE (${Math.ceil(player.techTimer/60)}s)</div>`;
            if (buffs.magnet > 0) container.innerHTML += `<div class="buff-item">üß≤ MAGNET (${Math.ceil(buffs.magnet/60)}s)</div>`;
        }

        function updatePowersList() {
            const list = document.getElementById('powers-list');
            list.innerHTML = '';
            for (const key in player.abilities) {
                const lvl = player.abilities[key];
                if (lvl > 0) {
                    const info = abilityInfo[key];
                    const div = document.createElement('div');
                    div.className = 'power-item';
                    const iconHtml = AbilityIcons[key] || '';
                    div.innerHTML = `<span class="power-icon">${iconHtml}</span> ${info.name} Lv.${lvl}`;
                    list.appendChild(div);
                }
            }
        }

        function selectUpgrade(index) {
            const choice = currentUpgradeChoices[index];
            if (choice) {
                player.abilities[choice.id] = Math.min(abilityInfo[choice.id].maxLevel, player.abilities[choice.id] + 1);
                updatePowersList();
                document.getElementById('upgrade-screen').style.display = 'none';
                gameState = 'PLAYING';
            }
        }

        function updateCardSelectionVisuals() {
            const cards = document.querySelectorAll('.card');
            cards.forEach((card, index) => {
                if (index === selectedUpgradeIndex) card.classList.add('selected');
                else card.classList.remove('selected');
            });
        }

        function levelUp() {
            playSound('levelup'); 
            gameState = 'LEVEL_UP';
            player.level++;
            player.xp = 0;
            player.xpToNextLevel = Math.floor(player.xpToNextLevel * 1.3);
            document.getElementById('level-display').innerText = player.level + '.0';
            
            const available = Object.values(abilityInfo).filter(a => player.abilities[a.id] < a.maxLevel);
            const choices = [];
            while (choices.length < 3 && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                choices.push(available.splice(idx, 1)[0]);
            }
            currentUpgradeChoices = choices;
            selectedUpgradeIndex = 0;

            const container = document.getElementById('cards-container');
            container.innerHTML = '';
            currentUpgradeChoices.forEach((c, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => selectUpgrade(index);
                card.onmouseenter = () => { selectedUpgradeIndex = index; updateCardSelectionVisuals(); };
                const iconHtml = AbilityIcons[c.id] || '';
                const nextLevel = player.abilities[c.id] + 1;
                card.innerHTML = `<div class="card-icon">${iconHtml}</div><h3>${c.name}</h3><p>${c.mechanic}</p><p>${c.getImprovement(nextLevel)}</p>`;
                container.appendChild(card);
            });
            updateCardSelectionVisuals();
            document.getElementById('upgrade-screen').style.display = 'flex';
        }

        function updateUI() {
            document.getElementById('hp-bar').style.width = (player.hp / player.maxHp * 100) + '%';
            document.getElementById('xp-bar').style.width = (player.xp / player.xpToNextLevel * 100) + '%';
        }

        function draw() {
            const camX = player.worldX - canvas.width / 2;
            const camY = player.worldY - canvas.height / 2;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            if (screenShake > 0.1) {
                ctx.translate(Math.random() * screenShake - screenShake/2, Math.random() * screenShake - screenShake/2);
            }

            // grid
            ctx.strokeStyle = '#3E44C6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const gridOffsetX = player.worldX % 100;
            const gridOffsetY = player.worldY % 100;
            for (let x = -gridOffsetX; x < canvas.width; x += 100) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = -gridOffsetY; y < canvas.height; y += 100) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();

            const startCol = Math.floor(camX / TILE_SIZE);
            const endCol = startCol + (canvas.width / TILE_SIZE) + 1;
            const startRow = Math.floor(camY / TILE_SIZE);
            const endRow = startRow + (canvas.height / TILE_SIZE) + 1;

            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    const obs = getObstacleAt(c, r);
                    if (obs) {
                        const sprite = barrierSprites[obs.spriteIndex];
                        if (sprite.complete) {
                            ctx.drawImage(sprite, obs.x - camX, obs.y - camY, OBSTACLE_SIZE, OBSTACLE_SIZE);
                        } else {
                            ctx.fillStyle = '#000';
                            ctx.fillRect(obs.x - camX, obs.y - camY, OBSTACLE_SIZE, OBSTACLE_SIZE);
                        }
                    }
                }
            }

            // aura visualization
            if (player.abilities.trueTradeArea > 0) {
                const radius = player.abilities.trueTradeArea * 60;
                ctx.save();
                ctx.globalAlpha = 0.3;
                if (player.abilities.trueTradeArea >= 3) {
                    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, radius*0.2, canvas.width/2, canvas.height/2, radius);
                    grad.addColorStop(0, 'red');
                    grad.addColorStop(1, 'blue');
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = 'rgba(0,0,255,0.2)';
                }
                ctx.beginPath();
                ctx.arc(canvas.width/2, canvas.height/2, radius, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
                if (player.abilities.trueTradeArea >=5) {
                    const sweepAngle = (frame * 0.05) % (Math.PI*2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2, canvas.height/2);
                    ctx.lineTo(canvas.width/2 + Math.cos(sweepAngle)*radius, canvas.height/2 + Math.sin(sweepAngle)*radius);
                    ctx.stroke();
                }
            }

            // trail & footsteps
            trail.forEach(t => {
                const alpha = t.life / 20;
                if (playerSprite.complete) {
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(playerSprite, t.x - camX - player.size/2, t.y - camY - player.size/2, player.size, player.size);
                    ctx.globalAlpha = 1.0;
                }
                if (t.color) {
                    ctx.fillStyle = t.color;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(t.x - camX, t.y - camY, 6, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            });

            magnetPickups.forEach(m => m.draw(ctx, camX, camY));
            piPickups.forEach(p => p.draw(ctx, camX, camY));
            storeLocations.forEach(h => h.draw(ctx, camX, camY));
            gems.forEach(g => g.draw(ctx, camX, camY));
            voidBeams.forEach(vb => vb.draw(ctx, camX, camY));
            bullets.forEach(b => b.draw(ctx, camX, camY));
            enemies.forEach(e => e.draw(ctx, camX, camY));
            damageNumbers.forEach(d => d.draw(ctx, camX, camY));
            particles.forEach(p => p.draw(ctx, camX, camY));

            // drones
            drones.forEach(d => d.draw(ctx, camX, camY));

            if (playerSprite.complete && playerSprite.naturalWidth !== 0) {
                ctx.drawImage(playerSprite, (canvas.width/2) - player.size/2 + player.recoilX, (canvas.height/2) - player.size/2 + player.recoilY, player.size, player.size);
            } else {
                ctx.fillStyle = '#676DFD';
                ctx.fillRect((canvas.width/2) - player.size/2 + player.recoilX, (canvas.height/2) - player.size/2 + player.recoilY, player.size, player.size);
            }

            // shield visual
            if (player.abilities.geoFencing > 0 && player.shieldHP > 0) {
                const lvl = player.abilities.geoFencing;
                const radius = player.size;
                ctx.save();
                ctx.translate(canvas.width/2, canvas.height/2);
                if (lvl >= 5) {
                    ctx.strokeStyle='rgba(0,200,255,0.5)';
                    ctx.lineWidth=2;
                    for(let i=0;i<6;i++){
                        ctx.rotate(Math.PI/3);
                        ctx.beginPath();
                        ctx.moveTo(radius,0);
                        ctx.lineTo(radius*1.2,0);
                        ctx.stroke();
                    }
                }
                ctx.beginPath();
                if (lvl >= 3) {
                    ctx.fillStyle='rgba(0,150,255,0.2)';
                    ctx.arc(0,0,radius+10,0,Math.PI*2);
                    ctx.fill();
                }
                ctx.strokeStyle='rgba(0,200,255,0.8)';
                ctx.setLineDash([5,5]);
                ctx.arc(0,0,radius+15,0,Math.PI*2);
                ctx.stroke();
                ctx.restore();
                ctx.setLineDash([]);
            }

            // forecasting max webs
            if (player.abilities.forecasting >= 5) {
                const originX = canvas.width/2;
                const originY = canvas.height/2 - 60;
                ctx.strokeStyle = 'rgba(0,255,255,0.7)';
                enemies.sort((a,b)=>Math.hypot(a.x-player.worldX,a.y-player.worldY)-Math.hypot(b.x-player.worldX,b.y-player.worldY));
                for (let i=0; i<Math.min(5,enemies.length); i++) {
                    const e = enemies[i];
                    ctx.beginPath();
                    ctx.moveTo(originX, originY);
                    ctx.lineTo(e.x - camX, e.y - camY);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        generateWorldStores();

        function gameLoop() {
            if (gameState === 'PLAYING' && !isPaused) {
                update();
            }
            draw();
            if (isPaused) document.getElementById('pause-screen').style.display = 'flex';
            else document.getElementById('pause-screen').style.display = 'none';
            requestAnimationFrame(gameLoop);
        }

        gameLoop();

    </script>
</body>
</html>